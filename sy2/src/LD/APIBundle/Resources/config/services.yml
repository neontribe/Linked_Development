services:
    sparql:
        class: LD\APIBundle\Services\ids\Sparql
        arguments: [%sparql_endpoint%, "@service_container"]

parameters:
    # This translates the Accepts header into supported mime types
    # Note that when multiple types are supplied the first one match will used.
    # The headers will be matched in the order listed here
    mimetypes:
      json:  ["application/json"]
      html:  ["text/html"]
      xhtml: ["application/xhtml+xml", "application/xhtmlxml"]
      xml:   ["application/xml"]

    graphs:
      # define input:default-graph-uri <foo>
      eldis: http://linked-development.org/eldis/
      r4d: http://linked-development.org/r4d/
      # all: ~, not used

    sparql_default_offset: 0
    sparql_default_limit: 10

    factories:
      count:
        documents:
          region: LD\APIBundle\Services\Factories\CountFactory
          theme: LD\APIBundle\Services\Factories\CountFactory
          country: LD\APIBundle\Services\Factories\CountFactory
        organisations:
          region: LD\APIBundle\Services\Factories\DefaultFactory
          theme: LD\APIBundle\Services\Factories\DefaultFactory
          country: LD\APIBundle\Services\Factories\DefaultFactory
      get:
        documents: LD\APIBundle\Services\Factories\DefaultFactory
        assets: LD\APIBundle\Services\Factories\DefaultFactory
        countries: LD\APIBundle\Services\Factories\DefaultFactory
        themes: LD\APIBundle\Services\Factories\DefaultFactory
        organisations: LD\APIBundle\Services\Factories\DefaultFactory
        region: LD\APIBundle\Services\Factories\DefaultFactory
      get_all:
        documents: LD\APIBundle\Services\Factories\DefaultFactory
        themes: LD\APIBundle\Services\Factories\DefaultFactory
      default: LD\APIBundle\Services\Factories\DefaultFactory

    sparqls:
      # Counts
      count:
        # Count Documents
        # IDS equivelent - http://api.ids.ac.uk/docs/functions/count/
        documents:
          region:
            # This demonstartes where multiple queries are needed.  The multiple index is set to true
            # IDS Example: http://api.ids.ac.uk/openapi/eldis/count/documents/region
            # Updated 2013/05/23
            multiquery: true
            none:
              define: ~
              select: select count(distinct ?article) as ?count
              where: >
                where {
                    ?article a <http://purl.org/ontology/bibo/Article> .
                    OPTIONAL { ?article <http://purl.org/dc/terms/coverage> ?region .
                        ?region a <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/geographical_region>.}
                    FILTER(!BOUND(?region))
                }
            all:
              define: ~
              select: select distinct ?region as ?url ?regionlabel as ?label count(distinct ?article) as ?count
              where: >
                where {
                     ?article a <http://purl.org/ontology/bibo/Article> .
                     ?article <http://purl.org/dc/terms/coverage> ?region .
                     ?region a <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/geographical_region>.
                     { 
                        ?region <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/nameList> ?regionlabel.
                     } UNION {
                        ?region <http://www.w3.org/2000/01/rdf-schema#label> ?regionlabel.
                     } 
                     FILTER(lang(?regionlabel) = 'en' || lang(?regionlabel) = "")
                }
          theme:
            # IDS example: http://api.ids.ac.uk/openapi/eldis/count/documents/theme
            # Note: the linked data API may return a very large list of themes here. We may wish to (a) sort the results by count; and (b) offer pagination
            # In future we may want to add a flag to switch between using the URI and the theme label to group themes
            # Right now we use the category. 
            multiquery: true
            none:
                define: ~
                select: select count(distinct ?article) as ?count
                where: >
                 where {
                        ?article a <http://purl.org/ontology/bibo/Article> .        
                        OPTIONAL { ?article <http://purl.org/dc/terms/subject> ?theme .}
                        FILTER(!BOUND(?theme))  
                 }
            all:
                define: ~
                select: select distinct ?theme as ?url ?identifier ?themelabel as ?label count(distinct ?article) as ?count
                where: >
                    where {
                           ?article a <http://purl.org/ontology/bibo/Article> .        
                           ?article <http://purl.org/dc/terms/subject> ?theme .
                           ?theme <http://www.w3.org/2000/01/rdf-schema#label> ?themelabel .
                           OPTIONAL { ?theme <http://purl.org/dc/terms/identifier> ?identifier. }
                    } ORDER BY DESC(?count)
          country:
            # Updated 2013/05/23
            # IDS Example: http://api.ids.ac.uk/openapi/eldis/count/documents/country
            multiquery: true
            none:
                define:
                select: select count(distinct ?article) as ?count
                where: >
                    where {
                        ?article a <http://purl.org/ontology/bibo/Article> .
                        OPTIONAL { 
                            ?article <http://purl.org/dc/terms/coverage> ?country .
                            ?country <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/codeISO2> ?countrycode.
                        }
                        FILTER(!BOUND(?country))
                    }
            all:
              #Note the need for the GROUP BY clause and string functions to cater for fact that the ISO codes may be typed or untyped in different datasets 
              define: ~
              select: select distinct str(?countrycode) as ?countrycode ?countrylabel count(distinct ?article) as ?count
              where: >
                where {
                  ?country <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/codeISO2> ?countrycode .
                  ?article a <http://purl.org/ontology/bibo/Article> .
                  ?article <http://purl.org/dc/terms/coverage> ?country .
                  { 
                    ?country <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/nameList> ?countrylabel.
                  } UNION {
                    ?country <http://www.w3.org/2000/01/rdf-schema#label> ?countrylabel.
                  } 
                  FILTER(lang(?countrylabel) = 'en' || lang(?countrylabel) = "")
                } GROUP BY str(?countrycode) ?countrylabel ORDER BY DESC(?count)

        # To support the ?q= operator the IDS API supports we would need something like the following fragment added to any of the queries above before the closing bracket of WHERE
        #
        #    {
        #      ?article <http://purl.org/dc/terms/subject> ?searchsubject.
        #      ?searchsubject <http://www.w3.org/2000/01/rdf-schema#label> ?search.
        #    } UNION {
        #      ?article <http://purl.org/dc/terms/title> ?search.
        #    }
        #    FILTER(regex(?search,'__KEYWORD__','i'))
        #
        # Which would search for the presence of the keyword in both the title of the article, and the subjects
        # Note that this is not directly comparable to IDS used of ?q which searches the 'keywords' field, which is not included in our merged IDS and R4D test dataset.


        # Count organisations
        #
        # We don't currently have adequate data across both IDS and R4D sources to fully implement this section
        #
        organisations:
          # http://api.ids.ac.uk/openapi/eldis/count/organisations/region
          # ToDo - Requires updates to eldis_crawl_orgs.py before it can be implemented. Does not work across R4D data at present.
          # ToDo - Review R4D organisation model
          region:
            define: ~
            select: ~
            where: ~
          theme:
          # http://api.ids.ac.uk/openapi/eldis/count/organisations/theme
          # ToDo - Needs to work from tags against organisations. May need to identify how to assign tags to R4D organisations. 
            define: ~
            select: ~
            where: ~
          country:
          # Country
          # http://api.ids.ac.uk/openapi/eldis/count/organisations/country
            define: ~
            select: SELECT ?country count(?org) as ?count
            where: >
              WHERE {
                {
                  ?org a <http://dbpedia.org/ontology/Organisation>.
                  ?org <http://schemas.talis.com/2005/address/schemacountryName> ?country.
                }
                UNION
                {
                  ?org a <http://xmlns.com/foaf/0.1/Organization>.
                  ?org <http://www.w3.org/2006/vcard/ns#hasAddress> ?address.
                  ?address <http://www.w3.org/2006/vcard/ns#country> ?country.
                }
              } GROUP BY ?country ORDER BY DESC(?count)
      # Gets
      get:
        # These CONSTRUCT based gets work for the long version of results. Simple selects could be used for short results. 
        # Example: http://api.ids.ac.uk/openapi/eldis/get/documents/A43073/full/the-state-of-governance-in-africa/
        documents:
          define: >
              PREFIX dcterms: <http://purl.org/dc/terms/>
              PREFIX bibo: <http://purl.org/ontology/bibo/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX fao: <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/>
          select: >
           CONSTRUCT {
               ?resource a bibo:Article.
               ?resource dcterms:title ?title.
               ?resource dcterms:abstract ?abstract.
               ?resource dcterms:creator ?creator.
               ?resource dcterms:subject ?subject.
               ?subject rdfs:label ?subjectTitle.
               ?subject dcterms:identifier ?subjectID.
               # Term relationships
               ?subject skos:broader ?subjectParent.
               ?subjectParent rdfs:label ?subjectParentLabel.
               ?subjectParent dcterms:identifier ?subjectParentID.
               # Coverage
               ?resource dcterms:coverage ?coverage.
               ?coverage rdfs:label ?coverageTitle.
               ?resource dcterms:language ?language.
               ?resource dcterms:identifier ?identifier.
               ?resource rdfs:seeAlso ?document.
               ?resource dcterms:date ?date.
               ?resource dcterms:publisher ?publisher.
               ?publisher foaf:name ?publisherName.
           }
          where: >
              WHERE {
                ?resource a bibo:Article.
                ?resource dcterms:title ?title.
                OPTIONAL { ?resource dcterms:abstract ?abstract. }
                # Creators
                # Handle cases where Creator is directly attached (Eldis), or through a blank node (R4D)
                OPTIONAL { 
                     { 
                     ?resource dcterms:creator ?creator. 
                     } UNION { 
                     ?resource dcterms:creator ?creatorURI. 
                     ?creatorURI foaf:name ?creator.
                     }
                 FILTER(isLiteral(?creator))
                }
                # Subjects
                OPTIONAL { 
                    ?resource dcterms:subject ?subject.
                    ?subject rdfs:label ?subjectTitle. 
                    OPTIONAL {
                        ?subject dcterms:identifier ?subjectID.
                    }
                    OPTIONAL {
                        ?subject skos:broader ?subjectParent
                        # Uncomment out the line below to search up the category tree and give all the required steps for building a category path
                        # This is expensive, so unless there are use-cases drawing on the category tree from the API we may want to leave it out
                        # OPTION (transitive, t_max(4), t_in(?subject), t_out(?subjectParent), t_step("step_no") as ?level)
                        .
                        ?subjectParent rdfs:label ?subjectParentLabel.
                        OPTIONAL { ?subjectParent dcterms:identifier ?subjectParentID. }
                    }
                }
                # Coverage
                OPTIONAL { 
                  ?resource dcterms:coverage ?coverage.
                  # Handle for different ways in which coverage may be labelled. 
                  { 
                   ?coverage rdfs:label ?coverageTitle.
                  } UNION {
                   ?coverage fao:nameList ?coverageTitle.
                   FILTER(lang(?coverageTitle) = 'en' || lang(?coverageTitle) = "")
                  }
                }
                # Language
                OPTIONAL { ?resource dcterms:language ?language. }
                # Identifiers
                OPTIONAL { ?resource dcterms:identifier ?identifier. }
                # SeeAlso
                OPTIONAL { ?resource rdfs:seeAlso ?document. }
                # Date
                OPTIONAL { ?resource dcterms:date ?date.}
                # Publisher Information
                OPTIONAL {
                    ?resource dcterms:publisher ?publisher.
                    OPTIONAL { ?publisher foaf:name ?publisherName. }
                }
                # URI to the document
                OPTIONAL {
                    ?resource bibo:uri ?uri.
                }
                FILTER(?resource = <__URI__>)
            }
        # Tested with __URI__ as <http://r4d.dfid.gov.uk/Output/10290/> and <http://linked-development.org/eldis/output/A43073/>
        # Note that this the query above could probably be re-used for all document/full queries in get, get_all and searc with different filter blocks
        # Alternate filter approaches could be applied to search based on ID
        # Though we may need some logic in the handlers to allow that IDs can be
        #  (a) URIs
        #  (b) Strings passing a regex like A{0-9}+ which are ELDIS IDs so should be prefixed with the ELDIS URI
        #  (c) Numerical, which we assume are R4D ids and prefix accordingly
        assets:
          define: ~
          select: select distinct ?a ?b
          where: >
            where {
              <http://linked-development.org/eldis/output/__ID__/> ?a ?b .
            }
        countries:
        # E.g. http://linked-development.org/eldis/countries/<ID>/
        # The example below run against a datastore containing R4D and ELDIS data may return multiple country names and repeated ISO codes
        # (for the different primary topics of countries in ELDIS and R4D). We should avoid duplicating in the output.
          define: >
              PREFIX dcterms: <http://purl.org/dc/terms/>
              PREFIX bibo: <http://purl.org/ontology/bibo/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX fao: <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/>
              PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          select: >
            CONSTRUCT {
               ?country a fao:territory.
               ?country fao:codeISO2 ?iso2.
               ?country fao:codeISO3 ?iso3.
               ?country fao:codeUN ?uncode.
               ?country rdfs:label ?countryName. 
               ?country dcterms:identifier ?identifier. #ObjectID
               ?country fao:isInGroup ?region.
               ?region rdfs:label ?regionName.
               ?region dcterms:identifiers ?regionID. 
             }
          where: >
            WHERE {
              ?country fao:codeISO2 ?iso2.
              OPTIONAL { ?country fao:codeISO3 ?iso3. }
              OPTIONAL { ?country fao:codeUN ?uncode. }
              { 
                ?country fao:nameList ?countryName.
                FILTER(lang(?countryName) = "en" || lang(?countryName) = "")
              } UNION { 
                ?country rdfs:label ?countryName. 
              }
              {?country fao:codeISO2 ?identifier} UNION {?country dcterms:identifier ?identifier.} 
              ?country fao:isInGroup ?region.
              ?region a fao:geographical_region.
              { 
                ?region fao:nameList ?regionName.
                FILTER(lang(?regionName) = "en" || lang(?regionName) = "")
              } UNION { 
                ?region rdfs:label ?regionName. 
              }
              #Best efforts to get a region ID we can use. 
              { ?region fao:codeUN ?regionID. } UNION {?region dcterms:identifier ?regionID. } UNION { ?region fao:codeFAOSTAT ?regionID. }
            }
            # This can be filtered with:    
            #  FILTER(str(?identifier) = "GH")  # For country code
            #  or 
            #  FILTER(regex(?countryName,"^Ghana$","i")) # For country name
            #
        themes:
          define: >
              PREFIX dcterms: <http://purl.org/dc/terms/>
              PREFIX bibo: <http://purl.org/ontology/bibo/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX fao: <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/>
              PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          select: >
              CONSTRUCT { 
                 # Only the primary subjects are given a skos:Concept - 
                 # so that in building output you can iterate through these
                 ?subject a skos:Concept.
                 ?subject rdfs:label ?subjectTitle.
                 ?subject dcterms:identifier ?identifier.
                 ?subject skos:broader ?subjectParent.
                 ?subjectParent rdfs:label ?subjectParentLabel.
                 ?subjectParent dcterms:identifier ?subjectParentID. 
                 ?subject skos:narrower ?subjectChild.
                 ?subjectChild rdfs:label ?subjectChildLabel.
                 ?subjectChild dcterms:identifier ?subjectChildID.
              }
          where: >
             WHERE {
               { SELECT ?subject WHERE {
                    ?subject a skos:Concept.
                    #This line checks that we only get subjects which have at least one article
                    #Otherwise with AgroVoc in our database we get lots of extra terms with no articles.   
                    FILTER EXISTS { ?article dcterms:subject ?subject. }
                    #
                    # Note that filters need to go in this nested SELECT, as in example below to fetch a particular category by ID
                    #  ?subject dcterms:identifier ?identifier.
                    #  FILTER(str(?identifier) = "C41")
                    # And limit and offset are here too.
                 } LIMIT 10 OFFSET 0
               }   
               #
               ?subject rdfs:label ?subjectTitle. 
               OPTIONAL { ?subject dcterms:identifier ?identifier. }
               FILTER(lang(?subjectTitle) = "en" || lang(?subjectTitle) = "")
               #
               OPTIONAL {
                 ?subject skos:broader ?subjectParent OPTION (transitive, t_max(4), t_in(?subject), t_out(?subjectParent), t_step("step_no") as ?level).
                 ?subjectParent rdfs:label ?subjectParentLabel.
                 OPTIONAL { ?subjectParent dcterms:identifier ?subjectParentID. }
                 FILTER(lang(?subjectParentLabel) = "en" || lang(?subjectParentLabel) = "")
               }
               #
               OPTIONAL {
                 ?subject skos:narrower ?subjectChild OPTION (transitive, t_max(4), t_in(?subject), t_out(?subjectChild), t_step("step_no") as ?level).
                 ?subjectChild rdfs:label ?subjectChildLabel.
                 OPTIONAL { ?subjectChild dcterms:identifier ?subjectChildID. }
                 FILTER(lang(?subjectChildLabel) = "en" || lang(?subjectChildLabel) = "")
               }
            }
        # Updates to the organisation data from R4D need to be made, and so we will await these before developing this section
        # TD to check if developers drawing upon organisation data at present. 
        organisations:
          define: ~
          select: select ?a ?b
          where: >
            where {
              <http://linked-development.org/eldis/organisation/A64953/> ?a ?b .
            }
        region:
        # Equivelent of http://api.ids.ac.uk/openapi/eldis/get_all/regions/full
        # Filters based on IDENTIFIER; UN CODE, then FAOSTAT code
          define: >
              PREFIX dcterms: <http://purl.org/dc/terms/>
              PREFIX bibo: <http://purl.org/ontology/bibo/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX fao: <http://www.fao.org/countryprofiles/geoinfo/geopolitical/resource/>
              PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          select: >
            CONSTRUCT {
                 ?region a fao:geographical_region.
                 ?region rdfs:label ?regionName.
                 ?region fao:codeUN ?codeUN.
                 ?region dcterms:identifier ?identifier.
              }
          where: >
           WHERE {
               ?region a fao:geographical_region.
               { 
                 ?region fao:nameList ?regionName.
                 FILTER(lang(?regionName) = "en" || lang(?regionName) = "")
               } UNION { 
                 ?region rdfs:label ?regionName. 
               }
               OPTIONAL {?region fao:codeUN ?codeUN. }
               { ?region dcterms:identifier ?identifier.} UNION { ?region fao:codeUN ?identifier. } UNION { ?region fao:codeFAOSTAT ?identifier. }
               # FILTER(str(?identifier) = "002")
            }
      # Get all
      # This can use the gets above just without filters, and making use of offsets etc.
      # Search can also use the gets above but adding filters
      get_all:
        documents:
          define: ~
          select: select distinct ?article ?also ?dcidentifier ?dctype ?dctitle ?dcdate ?dcabstract ?dccreator ?dccoverage ?dcpublisher  ?dclanguage ?theme
          where: >
            where {
                ?article a <http://purl.org/ontology/bibo/Article> .
                ?article <http://www.w3.org/2000/01/rdf-schema#seeAlso> ?also .
                ?article <http://purl.org/dc/terms/identifier> ?dcidentifier .
                ?article <http://purl.org/dc/terms/type> ?dctype .
                ?article <http://purl.org/dc/terms/title> ?dctitle  .
                ?article <http://purl.org/dc/terms/date> ?dcdate .
                ?article <http://purl.org/dc/terms/abstract> ?dcabstract .
                ?article <http://purl.org/dc/terms/creator> ?dccreator .
                ?article <http://purl.org/dc/terms/coverage> ?dccoverage .
                ?article <http://purl.org/dc/terms/publisher> ?dcpublisher .
                ?article <http://purl.org/dc/terms/language> ?dclanguage .
                ?article <http://purl.org/dc/terms/subject> ?theme .
            }
        themes:
          define: ~
          select: select distinct ?theme ?a ?b
          where: >
            where {?article <http://purl.org/dc/terms/subject> ?theme .
                ?theme ?a ?b .
            } order by ?theme

